"""
OCR Table Parser for Mexican CONDUSEF Statements

This module parses OCR-extracted table data from Mexican credit card statements
and converts it to the structured format expected by the database.

Author: StatementSense
Created: July 2025
"""

import re
import pandas as pd
from decimal import Decimal, InvalidOperation
from datetime import datetime
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass

from app.config import settings

logger = settings.get_logger(__name__)


@dataclass
class ParsedTransaction:
    """Represents a parsed transaction from OCR table data."""
    date: Optional[str] = None
    charge_date: Optional[str] = None
    description: str = ""
    amount: Optional[Decimal] = None
    transaction_type: str = "cargo"  # cargo or abono
    category: str = "otros"
    confidence: float = 0.5


@dataclass
class ParsedStatement:
    """Represents a complete parsed statement."""
    bank_name: Optional[str] = None
    customer_name: Optional[str] = None
    card_last_four: Optional[str] = None
    period_start: Optional[str] = None
    period_end: Optional[str] = None
    cut_date: Optional[str] = None
    due_date: Optional[str] = None
    pay_no_interest: Optional[Decimal] = None
    minimum_payment: Optional[Decimal] = None
    previous_balance: Optional[Decimal] = None
    total_charges: Optional[Decimal] = None
    total_payments: Optional[Decimal] = None
    credit_limit: Optional[Decimal] = None
    available_credit: Optional[Decimal] = None
    total_balance: Optional[Decimal] = None
    transactions: List[ParsedTransaction] = None
    confidence: float = 0.5

    def __post_init__(self):
        if self.transactions is None:
            self.transactions = []


class OCRTableParser:
    """
    Parser for OCR-extracted table data from Mexican CONDUSEF statements.
    
    Handles the structured table format generated by the table extraction service
    and converts it to the format expected by the database.
    """
    
    def __init__(self):
        self.logger = logger
        
        # Spanish month mapping for date parsing
        self.spanish_months = {
            'ENE': '01', 'FEB': '02', 'MAR': '03', 'ABR': '04',
            'MAY': '05', 'JUN': '06', 'JUL': '07', 'AGO': '08',
            'SEP': '09', 'OCT': '10', 'NOV': '11', 'DIC': '12'
        }
        
        # Transaction keywords for categorization (matching database enum values)
        self.transaction_categories = {
            'restaurante': 'alimentacion',
            'restaurant': 'alimentacion',
            'comida': 'alimentacion',
            'food': 'alimentacion',
            'gasolina': 'gasolineras',
            'gas': 'gasolineras',
            'pemex': 'gasolineras',
            'shell': 'gasolineras',
            'uber': 'transporte',
            'taxi': 'transporte',
            'metro': 'transporte',
            'autobus': 'transporte',
            'farmacia': 'salud',
            'pharmacy': 'salud',
            'medico': 'salud',
            'hospital': 'salud',
            'supermercado': 'otros',  # No compras category, use otros
            'supermarket': 'otros',
            'tienda': 'otros',
            'store': 'otros',
            'amazon': 'otros',
            'mercadolibre': 'otros',
            'oxxo': 'otros',
            'walmart': 'otros',
            'banco': 'servicios',
            'bank': 'servicios',
            'atm': 'servicios',
            'cajero': 'servicios',
            'santander': 'servicios',
            'bbva': 'servicios',
            'pago': 'transferencias',
            'payment': 'transferencias',
            'abono': 'transferencias',
            'transferencia': 'transferencias',
            'cine': 'entretenimiento',
            'netflix': 'entretenimiento',
            'spotify': 'entretenimiento',
            'ropa': 'ropa',
            'clothing': 'ropa',
            'zara': 'ropa',
            'seguro': 'seguros',
            'insurance': 'seguros',
            'escuela': 'educacion',
            'university': 'educacion',
            'interes': 'intereses_comisiones',
            'comision': 'intereses_comisiones',
            'interest': 'intereses_comisiones',
            'fee': 'intereses_comisiones',
        }
    
    def parse_tables(self, tables: List[pd.DataFrame], filename: str = None) -> ParsedStatement:
        """
        Parse extracted tables and return structured statement data.
        
        Args:
            tables: List of DataFrames from table extraction
            filename: Original filename for fallback period estimation
            
        Returns:
            ParsedStatement with extracted data
        """
        
        statement = ParsedStatement()
        
        try:
            # Parse customer and account info from all tables (header info might be anywhere)
            for i, table in enumerate(tables):
                self._parse_header_info(table, statement)
                if statement.bank_name and statement.period_start:
                    break  # Found what we need
            
            # If no period found and we have a filename, try to extract from filename
            if not statement.period_start and filename:
                period_from_filename = self._extract_period_from_filename(filename)
                if period_from_filename:
                    statement.period_start = period_from_filename
                    self.logger.info(f"Extracted period from filename: {period_from_filename}")
            
            # Parse transactions from all tables
            all_transactions = []
            for i, table in enumerate(tables):
                transactions = self._parse_table_transactions(table, i+1)
                all_transactions.extend(transactions)
            
            statement.transactions = all_transactions
            statement.confidence = self._calculate_confidence(statement)
            
            
            return statement
            
        except Exception as e:
            self.logger.error(f"OCR table parsing failed: {e}", exc_info=True)
            statement.confidence = 0.0
            return statement
    
    def _parse_header_info(self, table: pd.DataFrame, statement: ParsedStatement):
        """Extract customer and account information from header table."""
        try:
            # Convert table to text for pattern matching
            table_text = ' '.join(table.astype(str).values.flatten()).upper()
            
            # Extract bank name
            mexican_banks = ['SANTANDER', 'BBVA', 'BANAMEX', 'BANORTE', 'HSBC', 'SCOTIABANK', 'CITIBANAMEX']
            for bank in mexican_banks:
                if bank in table_text:
                    statement.bank_name = bank.title()
                    break
            
            # Extract period dates (CONDUSEF format)
            # Look for "PERIODO DE:" followed by dates
            period_patterns = [
                r'PERIODO\s*DE[:\s]+(\d{1,2}[-/]\w{3}[-/]\d{4})\s*AL?\s*(\d{1,2}[-/]\w{3}[-/]\d{4})',
                r'PERIODO[:\s]+(\d{1,2}[-/]\w{3}[-/]\d{4})\s*AL?\s*(\d{1,2}[-/]\w{3}[-/]\d{4})',
                r'DEL\s+(\d{1,2}[-/]\w{3}[-/]\d{4})\s*AL?\s*(\d{1,2}[-/]\w{3}[-/]\d{4})',
                r'FECHA\s*DE\s*CORTE[:\s]+(\d{1,2}[-/]\w{3}[-/]\d{4})',  # Cut date
            ]
            
            for pattern in period_patterns:
                match = re.search(pattern, table_text)
                if match:
                    if len(match.groups()) == 2:  # Period start and end
                        start_date = self._parse_date(match.group(1))
                        end_date = self._parse_date(match.group(2))
                        if start_date:
                            statement.period_start = start_date
                        if end_date:
                            statement.period_end = end_date
                    elif len(match.groups()) == 1:  # Just cut date
                        cut_date = self._parse_date(match.group(1))
                        if cut_date:
                            statement.cut_date = cut_date
                            # Estimate period start (usually 1 month before cut date)
                            try:
                                # cut_date is now a datetime object
                                if cut_date.month == 1:
                                    period_start = cut_date.replace(year=cut_date.year-1, month=12, day=1)
                                else:
                                    period_start = cut_date.replace(month=cut_date.month-1, day=1)
                                statement.period_start = period_start
                            except:
                                pass
                    break
            
            # If no period found, try alternative patterns
            if not statement.period_start:
                # Look for any date that might be the period start
                alt_patterns = [
                    r'(\d{1,2}[-/]\w{3}[-/]\d{4})',  # Any date in Mexican format
                ]
                
                dates_found = []
                for pattern in alt_patterns:
                    matches = re.findall(pattern, table_text)
                    for match in matches:
                        parsed_date = self._parse_date(match)
                        if parsed_date:
                            dates_found.append(parsed_date)
                
                # Use the earliest date as period start if we found any
                if dates_found:
                    dates_found.sort()
                    statement.period_start = dates_found[0]
                    self.logger.info(f"Estimated period start from available dates: {statement.period_start}")
            
            # Extract customer name (look for name-like patterns)
            for row in table.itertuples():
                for cell in row[1:]:  # Skip index
                    if isinstance(cell, str) and len(cell) > 10:
                        # Look for potential customer names (letters and spaces, reasonable length)
                        if re.match(r'^[A-Z\s]{10,50}$', str(cell).upper()):
                            # Skip obvious non-names
                            if not any(word in cell.upper() for word in ['SANTANDER', 'TARJETA', 'CREDIT', 'ESTADO']):
                                statement.customer_name = cell.strip()
                                break
            
            # Extract card number (look for 16-digit patterns)
            card_patterns = [
                r'\d{4}[\s-]?\d{4}[\s-]?\d{4}[\s-]?\d{4}',  # Full card number
                r'\*{12}\d{4}',  # Masked card number
                r'XXXX\s*XXXX\s*XXXX\s*\d{4}'  # X-masked card number
            ]
            
            for pattern in card_patterns:
                match = re.search(pattern, table_text)
                if match:
                    card_number = match.group()
                    # Extract last 4 digits
                    last_four = re.findall(r'\d{4}', card_number)[-1] if re.findall(r'\d{4}', card_number) else None
                    if last_four:
                        statement.card_last_four = last_four
                        break
            
        except Exception as e:
            self.logger.warning(f"Header info parsing failed: {e}")
    
    def _parse_table_transactions(self, table: pd.DataFrame, table_num: int) -> List[ParsedTransaction]:
        """Parse transactions from a single table."""
        transactions = []
        
        try:
            
            # Skip very small tables (likely headers or footers)
            if len(table) < 3:
                return transactions
            
            # Try to identify transaction-like rows
            for row_idx, row in table.iterrows():
                try:
                    transaction = self._parse_row_as_transaction(row, row_idx, table_num)
                    if transaction and transaction.description:  # Only add if we got some data
                        transactions.append(transaction)
                except Exception as e:
                    continue  # Skip problematic rows
            
            
        except Exception as e:
            self.logger.warning(f"Table {table_num} transaction parsing failed: {e}")
        
        return transactions
    
    def _parse_row_as_transaction(self, row: pd.Series, row_idx: int, table_num: int) -> Optional[ParsedTransaction]:
        """Parse a single row as a potential transaction."""
        try:
            # Convert row to list of strings
            cells = [str(cell).strip() for cell in row if pd.notna(cell) and str(cell).strip()]
            
            # Skip empty or very short rows
            if len(cells) < 2:
                return None
            
            # Skip header-like rows
            if any(header in ' '.join(cells).upper() for header in [
                'FECHA', 'DATE', 'DESCRIPCION', 'DESCRIPTION', 'MONTO', 'AMOUNT',
                'SANTANDER', 'PAGINA', 'TABLA', 'TABLE'
            ]):
                return None
            
            transaction = ParsedTransaction()
            
            # Try to extract date from first few cells
            date_found = False
            for i, cell in enumerate(cells[:3]):
                date = self._parse_date(cell)
                if date:
                    if not date_found:
                        transaction.date = date
                        date_found = True
                    else:
                        transaction.charge_date = date
                    break
            
            # Build description from text cells
            description_parts = []
            amount_found = False
            
            for cell in cells:
                # Try to parse as amount
                amount = self._parse_amount(cell)
                if amount and not amount_found:
                    transaction.amount = amount
                    # Determine transaction type based on amount context (database enum values)
                    if '-' in cell or 'PAGO' in cell.upper() or 'ABONO' in cell.upper():
                        transaction.transaction_type = 'abono'  # Credit/Payment
                    else:
                        transaction.transaction_type = 'cargo'  # Charge/Debit
                    amount_found = True
                else:
                    # Add to description if it's meaningful text
                    if len(cell) > 2 and not cell.isdigit() and cell != 'None':
                        description_parts.append(cell)
            
            # Set description
            if description_parts:
                transaction.description = ' '.join(description_parts)
                transaction.category = self._categorize_transaction(transaction.description)
            else:
                return None  # No meaningful description found
            
            # Set default date if none found
            if not transaction.date:
                from datetime import datetime
                transaction.date = datetime(2025, 5, 1)  # Default date for statements without clear dates
            
            # Only return if we have description
            if transaction.description:
                return transaction
            
            return None
            
        except Exception as e:
            return None
    
    def _parse_date(self, text: str) -> Optional[str]:
        """Parse date from text in various Mexican formats."""
        if not text or len(text) < 6:
            return None
        
        try:
            text = str(text).strip().upper()
            
            # Mexican format: DD-MMM-YYYY
            date_patterns = [
                r'(\d{1,2})-(ENE|FEB|MAR|ABR|MAY|JUN|JUL|AGO|SEP|OCT|NOV|DIC)-(\d{4})',
                r'(\d{1,2})/(ENE|FEB|MAR|ABR|MAY|JUN|JUL|AGO|SEP|OCT|NOV|DIC)/(\d{4})',
                r'(\d{1,2})-(\d{1,2})-(\d{4})',  # DD-MM-YYYY
                r'(\d{1,2})/(\d{1,2})/(\d{4})',  # DD/MM/YYYY
            ]
            
            for pattern in date_patterns:
                match = re.search(pattern, text)
                if match:
                    day, month, year = match.groups()
                    
                    # Convert Spanish month to number if needed
                    if month in self.spanish_months:
                        month = self.spanish_months[month]
                    
                    # Return as datetime object
                    try:
                        from datetime import datetime
                        return datetime(int(year), int(month), int(day))
                    except:
                        continue
            
            return None
            
        except Exception:
            return None
    
    def _parse_amount(self, text: str) -> Optional[Decimal]:
        """Parse monetary amount from text."""
        if not text:
            return None
        
        try:
            text = str(text).strip()
            
            # Amount patterns
            amount_patterns = [
                r'[\$]?\s*([\d,]+\.?\d*)',  # $1,234.56 or 1,234.56
                r'([\d,]+)\s*[\$]',         # 1,234$
                r'^\s*([\d,]+\.?\d*)\s*$'   # Plain number
            ]
            
            for pattern in amount_patterns:
                match = re.search(pattern, text)
                if match:
                    amount_str = match.group(1).replace(',', '')
                    if amount_str and amount_str.replace('.', '').isdigit():
                        return Decimal(amount_str)
            
            return None
            
        except (InvalidOperation, ValueError):
            return None
    
    def _categorize_transaction(self, description: str) -> str:
        """Categorize transaction based on description."""
        if not description:
            return 'otros'
        
        description_lower = description.lower()
        
        for keyword, category in self.transaction_categories.items():
            if keyword in description_lower:
                return category
        
        return 'otros'
    
    def _extract_period_from_filename(self, filename: str) -> Optional[str]:
        """Extract period date from filename patterns."""
        try:
            if not filename:
                return None
            
            filename_upper = filename.upper()
            
            # Spanish month patterns in filenames
            month_patterns = {
                'ENERO': '01', 'FEBRERO': '02', 'MARZO': '03', 'ABRIL': '04',
                'MAYO': '05', 'JUNIO': '06', 'JULIO': '07', 'AGOSTO': '08',
                'SEPTIEMBRE': '09', 'OCTUBRE': '10', 'NOVIEMBRE': '11', 'DICIEMBRE': '12'
            }
            
            # Look for patterns like "mayo 2025", "estado mayo 2025", etc.
            for month_name, month_num in month_patterns.items():
                if month_name in filename_upper:
                    # Look for year after month
                    year_match = re.search(f'{month_name}\\s*(\\d{{4}})', filename_upper)
                    if year_match:
                        year = year_match.group(1)
                        # Return first day of the month as period start
                        # Return as datetime object
                        from datetime import datetime
                        return datetime(int(year), int(month_num), 1)
            
            # Look for numeric patterns like "05-2025" or "2025-05"
            date_patterns = [
                r'(\d{1,2})-(\d{4})',  # MM-YYYY
                r'(\d{4})-(\d{1,2})',  # YYYY-MM
                r'(\d{1,2})(\d{4})',   # MMYYYY
            ]
            
            for pattern in date_patterns:
                match = re.search(pattern, filename)
                if match:
                    part1, part2 = match.groups()
                    # Determine which is month and which is year
                    if len(part1) == 4:  # part1 is year
                        year, month = part1, part2.zfill(2)
                    else:  # part2 is year
                        month, year = part1.zfill(2), part2
                    
                    # Validate month
                    if 1 <= int(month) <= 12:
                        from datetime import datetime
                        return datetime(int(year), int(month), 1)
            
            return None
            
        except Exception as e:
            self.logger.warning(f"Failed to extract period from filename {filename}: {e}")
            return None
    
    def _calculate_confidence(self, statement: ParsedStatement) -> float:
        """Calculate overall confidence score for the parsed statement."""
        confidence_factors = []
        
        # Bank name confidence
        if statement.bank_name:
            confidence_factors.append(0.8)
        
        # Customer name confidence
        if statement.customer_name:
            confidence_factors.append(0.7)
        
        # Card number confidence
        if statement.card_last_four:
            confidence_factors.append(0.6)
        
        # Transaction confidence
        if statement.transactions:
            transaction_confidence = 0.5
            
            # Boost confidence if we have dates and amounts
            transactions_with_dates = sum(1 for t in statement.transactions if t.date)
            transactions_with_amounts = sum(1 for t in statement.transactions if t.amount)
            
            if transactions_with_dates > len(statement.transactions) * 0.5:
                transaction_confidence += 0.2
            
            if transactions_with_amounts > len(statement.transactions) * 0.3:
                transaction_confidence += 0.2
            
            confidence_factors.append(transaction_confidence)
        
        # Calculate weighted average
        if confidence_factors:
            return sum(confidence_factors) / len(confidence_factors)
        else:
            return 0.3  # Base confidence for OCR extraction
    
    def to_mexican_parser_format(self, statement: ParsedStatement) -> Dict:
        """Convert parsed statement to Mexican parser output format."""
        result = {
            "success": len(statement.transactions) > 0,
            "confidence": statement.confidence,
            "extraction_method": "mexican_template",  # Map OCR to existing enum
            "metadata": {
                "bank_name": statement.bank_name,
                "customer_name": statement.customer_name,
                "card_last_four": statement.card_last_four,
                "period_start": statement.period_start,
                "period_end": statement.period_end,
                "cut_date": statement.cut_date,
                "due_date": statement.due_date,
                "pay_no_interest": float(statement.pay_no_interest) if statement.pay_no_interest else None,
                "minimum_payment": float(statement.minimum_payment) if statement.minimum_payment else None,
                "previous_balance": float(statement.previous_balance) if statement.previous_balance else None,
                "total_charges": float(statement.total_charges) if statement.total_charges else None,
                "total_payments": float(statement.total_payments) if statement.total_payments else None,
                "credit_limit": float(statement.credit_limit) if statement.credit_limit else None,
                "available_credit": float(statement.available_credit) if statement.available_credit else None,
                "total_balance": float(statement.total_balance) if statement.total_balance else None,
            },
            "transactions": []
        }
        
        # Convert transactions
        for tx in statement.transactions:
            transaction = {
                "date": tx.date,
                "charge_date": tx.charge_date,
                "description": tx.description,
                "amount": float(tx.amount) if tx.amount else 0.0,
                "type": "DEBIT" if tx.transaction_type == "cargo" else "CREDIT",
                "category": tx.category,
                "original_category": tx.category,
                "confidence": tx.confidence,
            }
            result["transactions"].append(transaction)
        
        return result


# Create singleton instance
ocr_table_parser = OCRTableParser()